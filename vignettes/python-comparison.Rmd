---
title: "Comparison with Python Logging Solutions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Comparison with Python Logging Solutions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(logthis)
```

## Introduction

If you're coming from Python and familiar with its logging ecosystem, this guide will help you understand how `logthis` compares to popular Python logging solutions. While R and Python have different idioms, `logthis` provides enterprise-level logging capabilities comparable to Python's mature frameworks.

This comparison covers:

- **Python's built-in `logging` module** - The standard library solution
- **loguru** - A modern, simplified logging library
- **structlog** - A structured logging framework

## Architecture Overview

### Conceptual Comparison

All four frameworks share similar architectural concepts, but with different implementations:

| Component | Python logging | loguru | structlog | logthis |
|-----------|---------------|---------|-----------|---------|
| **Core Design** | Hierarchical namespace loggers | Single pre-configured logger | Structured output focus | Functional composition |
| **Message Routing** | Loggers → Handlers → Output | Direct output with sinks | Processors → Output | Loggers → Receivers → Output |
| **Configuration** | Imperative (dict/file) | Minimal/zero config | Pipeline-based | Pipe-friendly functional |
| **Filtering** | Logger + Handler levels | Sink-level filtering | Processor-based | Two-level (logger + receiver) |
| **State Management** | Global registry | Global instance | Bound loggers | Explicit objects |

### Key Architectural Similarities

**logthis most closely resembles Python's `logging` module** in its handler/receiver pattern and two-level filtering, but uses **functional composition** inspired by R's pipe operators (`%>%`) rather than imperative configuration.

## Feature Comparison

### 1. Python's Built-in `logging` Module

Python's standard library logging module uses a hierarchical namespace with loggers, handlers, and formatters.

**Python code:**

```python
import logging

# Configure logger with handler
logger = logging.getLogger('myapp')
logger.setLevel(logging.DEBUG)

handler = logging.FileHandler('app.log')
handler.setLevel(logging.WARNING)
formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger.addHandler(handler)

logger.debug("This won't appear in file")
logger.warning("This will appear in file")
```

**Equivalent in logthis:**

```{r python-logging-equiv, eval=FALSE}
log_this <- logger() %>%
  with_receivers(
    to_text() %>%
      on_local(path = "app.log") %>%
      with_limits(lower = WARNING)
  ) %>%
  with_limits(lower = DEBUG)

log_this(DEBUG("This won't appear in file"))
log_this(WARNING("This will appear in file"))
```

**Key Differences:**

- **Namespace hierarchy**: Python uses `logger.child.grandchild` propagation; logthis uses scope-based masking
- **Global state**: Python stores loggers in a global registry; logthis uses explicit logger objects
- **Configuration**: Python uses dict-based or file-based config; logthis uses pipe-based functional composition

### 2. loguru - Simplified Logging

loguru provides a pre-configured, easy-to-use logging interface with a single global logger.

**Python code:**

```python
from loguru import logger

# Pre-configured, just add sinks
logger.add("app.log", rotation="500 MB", level="WARNING")
logger.add("debug.log", level="DEBUG")

logger.debug("Detailed debug info")
logger.warning("This goes to both files")
```

**Equivalent in logthis:**

```{r loguru-equiv, eval=FALSE}
log_this <- logger() %>%
  with_receivers(
    to_text() %>%
      on_local(path = "app.log", max_size = 5e8) %>%
      with_limits(lower = WARNING),
    to_text() %>%
      on_local(path = "debug.log") %>%
      with_limits(lower = DEBUG)
  )

log_this(DEBUG("Detailed debug info"))
log_this(WARNING("This goes to both files"))
```

**Key Differences:**

- **Single global logger**: loguru has one logger instance; logthis supports multiple independent loggers
- **Automatic rotation**: loguru has built-in file rotation; logthis requires manual configuration
- **Testing**: Both support easy testing (loguru's `_default` handler removal, logthis's `to_itself()`)

**Similarities:**

- Pre-configured defaults for quick setup
- Simple, clean API
- Support for multiple output destinations

### 3. structlog - Structured Logging

structlog focuses on structured output (JSON, Logfmt) with a processor chain architecture.

**Python code:**

```python
import structlog

structlog.configure(
    processors=[
        structlog.processors.add_log_level,
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.JSONRenderer()
    ]
)

logger = structlog.get_logger()
logger = logger.bind(user_id="12345")  # Context binding
logger.info("user_action", action="login")
```

**Equivalent in logthis:**

```{r structlog-equiv, eval=FALSE}
log_this <- logger() %>%
  with_receivers(to_json() %>% on_local(path = "app.jsonl")) %>%
  with_tags("user:12345")  # Tag-based context

log_this(NOTE("user_action", action = "login"))
```

**Key Differences:**

- **Processor chain**: structlog uses explicit processing pipeline; logthis uses receiver pattern
- **Integration focus**: structlog wraps existing loggers; logthis is standalone
- **Context managers**: Python-specific context binding; logthis uses scope-based masking

**Similarities:**

- First-class support for structured output (JSON)
- Context/metadata binding (structlog's `bind()`, logthis's `with_tags()`)
- Composable, customizable architecture

## Common Tasks: Side-by-Side

### Basic Setup

**Python (logging):**
```python
import logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
logger.info("Started")
```

**logthis:**
```{r basic-setup, eval=FALSE}
log_this <- logger() %>%
  with_receivers(to_console()) %>%
  with_limits(lower = NOTE)
log_this(NOTE("Started"))
```

### Multiple Outputs

**Python (loguru):**
```python
logger.add("file.log", level="ERROR")
logger.add("debug.log", level="DEBUG")
```

**logthis:**
```{r multi-output, eval=FALSE}
log_this <- logger() %>%
  with_receivers(
    to_text() %>% on_local("file.log") %>% with_limits(lower = ERROR),
    to_text() %>% on_local("debug.log") %>% with_limits(lower = DEBUG)
  )
```

### Structured/JSON Logging

**Python (structlog):**
```python
logger.info("event", user_id=123, action="login")
```

**logthis:**
```{r structured, eval=FALSE}
log_this(NOTE("event", user_id = 123, action = "login"))
```

### Context Binding

**Python (structlog):**
```python
logger = logger.bind(request_id="abc-123")
logger.info("Processing request")
```

**logthis:**
```{r context-binding, eval=FALSE}
log_this <- log_this %>% with_tags("request:abc-123")
log_this(NOTE("Processing request"))
```

### Error Handling

**Python (loguru):**
```python
@logger.catch
def risky_function():
    1 / 0
```

**logthis:**
```{r error-handling, eval=FALSE}
tryCatch({
  1 / 0
}, error = function(e) {
  log_this(ERROR(paste("Error:", e$message)))
})
```

## Unique Features of logthis

### 1. Functional Composition

Pure R pipe-based design with no global state modification:

```{r functional-composition, eval=FALSE}
# Immutable transformations
base_logger <- logger() %>% with_receivers(to_console())
debug_logger <- base_logger %>% with_limits(lower = DEBUG)
prod_logger <- base_logger %>% with_limits(lower = WARNING)

# base_logger is unchanged
```

### 2. Scope-Based Logger Enhancement

R's lexical scoping enables temporary logger modifications:

```{r scope-based, eval=FALSE}
# Parent logger
log_this <- logger() %>% with_receivers(to_console())

my_function <- function() {
  # Local enhancement - doesn't affect parent
  log_this <- log_this %>% with_receivers(to_text() %>% on_local("local.log"))
  log_this(NOTE("Only in this scope"))
}

my_function()
log_this(NOTE("Back to parent logger"))  # No file output
```

### 3. Formatter + Handler Pattern

Explicitly separate formatting from output destination:

```{r formatter-handler, eval=FALSE}
# Same format, different destinations
json_formatter <- to_json()

logger() %>%
  with_receivers(
    json_formatter %>% on_local("local.jsonl"),
    json_formatter %>% on_s3(bucket = "logs", key_prefix = "app"),
    json_formatter %>% on_azure(container = "logs", blob = "events.jsonl")
  )
```

### 4. Resilient Receiver Execution

Automatic failover with `purrr::safely()`:

```{r resilient, eval=FALSE}
# If one receiver fails, others continue
log_this <- logger() %>%
  with_receivers(
    to_console(),
    to_text() %>% on_local("/readonly/path.log"),  # May fail
    to_json() %>% on_s3(bucket = "logs")           # Still runs
  )

log_this(NOTE("Message"))
# Console and S3 receive message even if file write fails
```

### 5. Shiny Integration

Built-in UI receivers for interactive applications:

```{r shiny-integration, eval=FALSE}
library(shiny)

log_this <- logger() %>%
  with_receivers(
    to_console(lower = NOTE),
    to_shinyalert(lower = ERROR),
    to_notif(lower = WARNING)
  )

# Errors show as modal alerts
log_this(ERROR("Critical error"))

# Warnings show as notifications
log_this(WARNING("Warning message"))
```

### 6. Granular 0-100 Level Scale

More precise than traditional 5-level systems:

```{r granular-levels, eval=FALSE}
# Define custom levels at any point
BUSINESS <- log_event_level("BUSINESS", 50)  # Between MESSAGE and WARNING
AUDIT <- log_event_level("AUDIT", 35)        # Between NOTE and MESSAGE

log_this <- logger() %>%
  with_receivers(to_console()) %>%
  with_limits(lower = 30, upper = 70)  # Inclusive range

log_this(AUDIT("Audit event"))      # 35 - included
log_this(BUSINESS("KPI reached"))   # 50 - included
log_this(ERROR("Error"))            # 80 - excluded
```

## Design Philosophy Comparison

| Aspect | Python logging | loguru | structlog | logthis |
|--------|---------------|---------|-----------|---------|
| **Paradigm** | OOP, Imperative | Functional-lite | Pipeline | Pure Functional |
| **State Management** | Global registry | Global instance | Bound loggers | Explicit objects |
| **Configuration** | Dict/File | Method calls | Processors | Pipe composition |
| **Extensibility** | Subclass handlers | Custom sinks | Custom processors | Custom receivers/formatters |
| **Testing** | Mock/patch | Context manager | Test processors | Identity receiver |

## Migration Guide for Python Developers

### Conceptual Mapping

| Python Concept | logthis Equivalent | Notes |
|---------------|-------------------|-------|
| `logger.getLogger()` | `logger()` | Explicit object creation |
| Handler | Receiver | Determines output destination |
| Formatter | Formatter (to_text, to_json) | Defines output format |
| `logger.addHandler()` | `with_receivers()` | Pipe-based composition |
| `logger.setLevel()` | `with_limits()` | Logger-level filtering |
| Handler filter | Receiver `with_limits()` | Receiver-level filtering |
| `logger.bind()` (structlog) | `with_tags()` | Context/metadata binding |
| Sink (loguru) | Receiver | Output destination |

### Common Patterns

**Python namespace hierarchy:**
```python
logger = logging.getLogger("app.module.component")
```

**logthis scope-based approach:**
```{r scope-approach, eval=FALSE}
# Module-specific logger
module_logger <- logger() %>% with_tags("module:component")
```

**Python context manager:**
```python
with logger.contextualize(request_id=123):
    logger.info("Processing")
```

**logthis scope masking:**
```{r scope-masking, eval=FALSE}
process_request <- function(request_id) {
  log_this <- log_this %>% with_tags(paste0("request:", request_id))
  log_this(NOTE("Processing"))
}
```

## When to Choose Each Solution

### Choose Python `logging` when:
- Working with stdlib-only requirements
- Need hierarchical logger namespaces
- Integrating with Python frameworks (Django, Flask)
- Complex enterprise configurations via files

### Choose `loguru` when:
- Rapid prototyping in Python
- Want zero-config simplicity
- Need automatic log rotation
- Don't need multiple logger instances

### Choose `structlog` when:
- Structured JSON logging is critical
- Need to wrap/enhance existing loggers
- Building observability pipelines
- Working with log aggregation systems (ELK, Datadog)

### Choose `logthis` when:
- Working in R ecosystem
- Need functional, composable design
- Want Shiny application integration
- Prefer explicit state over global configuration
- Need scope-based logger enhancement
- Building R packages with logging
- Want resilient error handling
- Need cloud storage integration (S3, Azure)

## Performance Considerations

### Python Solutions

- **logging**: Good performance, but can be slow with many handlers
- **loguru**: Slightly slower than stdlib due to features, but negligible for most use cases
- **structlog**: Performance depends on processor chain length

### logthis

- **Functional composition**: No global state lookup overhead
- **Resilient receivers**: `purrr::safely()` wrapper adds minimal overhead
- **Lazy evaluation**: R's lazy evaluation can optimize pipe chains
- **Cloud receivers**: Buffering reduces network overhead

Benchmark vignette available separately for detailed performance analysis.

## Conclusion

**logthis brings Python-level logging maturity to R** with a uniquely R-flavored design:

- **Conceptual Familiarity**: Similar to Python's `logging` module architecture
- **Modern Simplicity**: Inspired by loguru's ease of use
- **Structured Output**: Like structlog's JSON-first approach
- **R Idioms**: Leverages pipes, functional composition, and lexical scoping

Whether you're migrating from Python or building R applications from scratch, logthis provides a powerful, flexible logging framework that feels natural in R while offering capabilities comparable to Python's mature ecosystem.

## Further Reading

- [Getting Started](getting-started.html) - Quick introduction to logthis
- [Advanced Receivers](advanced-receivers.html) - Cloud storage, webhooks, and custom receivers
- [Patterns](patterns.html) - Common logging patterns and best practices
- [Tagging and Provenance](tagging-and-provenance.html) - Using tags for context and audit trails

## References

- [Python logging documentation](https://docs.python.org/3/library/logging.html)
- [loguru GitHub repository](https://github.com/Delgan/loguru)
- [structlog documentation](https://www.structlog.org/)
- [Logging in Python: A Comparison](https://betterstack.com/community/guides/logging/best-python-logging-libraries/)
