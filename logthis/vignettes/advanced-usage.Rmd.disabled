---
title: "Advanced Usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Advanced Usage}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(logthis)
```

# Advanced logthis Usage

This vignette covers advanced features and patterns for using `logthis` in production applications.

## Logger Chaining and Composition

One of the most powerful features of `logthis` is the ability to chain loggers and compose them flexibly within different scopes.

### Basic Logger Chaining

Loggers return log events invisibly, allowing you to chain multiple loggers together:

```{r chaining-basic}
# Create specialized loggers
log_this_console <- logger() %>% with_receivers(to_console())
log_this_capture <- logger() %>% with_receivers(to_identity())

# Chain them - event goes through both
result <- WARNING("System warning") %>%
    log_this_console() %>%
    log_this_capture()

# The final result is the original log event
print(result$message)
print(result$level_class)
```

### Scope-Based Logger Enhancement  

You can enhance loggers within specific scopes without affecting the parent scope:

```{r scope-enhancement}
```{r scope-enhancement}
# Base logger in outer scope
log_this <- logger() %>% with_receivers(to_console())

process_data <- function() {
    # Add file logging within this scope only  
    log_this <- log_this %>% 
        with_receivers(to_identity())  # represents file logger
    
    log_this(NOTE("Processing data with enhanced logging"))
    
    # Nested function with additional receivers
    validate_data <- function() {
        log_this <- log_this %>%
            with_receivers(to_void())  # represents alert system
        
        log_this(WARNING("Data validation with full logging stack"))
    }
    
    validate_data()
}

# Base logger unchanged outside scope
log_this(NOTE("Back to base logger functionality"))
```
```

### Logger Pipelines

Create reusable logging pipelines:

```{r logger-pipelines}
# Define a logging pipeline
create_audit_pipeline <- function() {
    console_logger <- logger() %>% with_receivers(to_console())
    audit_logger <- logger() %>% with_receivers(to_identity())
    alert_logger <- logger() %>% with_receivers(to_void())
    
    function(event) {
        event %>%
            console_logger() %>%
            audit_logger() %>%
            alert_logger()
    }
}

audit_log <- create_audit_pipeline()

# Use the pipeline
audit_log(ERROR("Security violation detected"))
```

## Two-Level Filtering Architecture

Understanding `logthis` filtering architecture is crucial for building efficient logging systems:

### Filter Execution Order

1. **Logger-level filter** (`with_limits()`) - Applied first
2. **Receiver-level filters** (`lower`/`upper`) - Applied second

```{r filtering-architecture}
# Complex filtering scenario
multi_filter_logger <- logger() %>%
    with_receivers(
        to_console(lower = WARNING, upper = ERROR),     # Console: WARNING to ERROR
        to_identity(),                                          # File: all events (no receiver filter)
        to_void()                                              # Monitor: all events (silent)
    ) %>%
    with_limits(lower = NOTE, upper = HIGHEST)                 # Logger: NOTE and above

# Event processing flow:
# CHATTER(10) -> Blocked by logger filter (< 40)
# NOTE(40)    -> Passes logger, reaches file & monitor only (< 80)  
# WARNING(80) -> Passes logger, reaches all three receivers
# ERROR(100)  -> Passes logger, reaches all three receivers
# HIGHEST(120) -> Blocked by logger filter (> 120) 
```

### Performance Optimization

Logger-level filtering is more efficient than receiver-level filtering:

```{r performance-filtering}
# Efficient: Logger blocks low-priority events early
log_this <- logger() %>%
    with_receivers(
        to_console(),
        to_identity(),  # Represents expensive file I/O
        to_void()       # Represents expensive network call
    ) %>%
    with_limits(lower = ERROR, upper = HIGHEST)  # Block most events at logger level

# Less efficient: All events reach expensive receivers  
log_this_inefficient <- logger() %>%
    with_receivers(
        to_console(lower = ERROR),
        to_identity(),  # Still processes all events
        to_void()       # Still processes all events  
    )
    # No logger-level filtering
```

### Environment-Specific Filtering

```{r env-filtering}
create_env_logger <- function(env = "development") {
    log_this <- logger()
    
    if (env == "production") {
        # Production: restrictive logger filter, specific receiver filters
        log_this %>%
            with_receivers(
                to_console(lower = ERROR),        # Console: errors only
                to_identity()                         # File: all events that pass logger
            ) %>%
            with_limits(lower = WARNING, upper = HIGHEST)  # Logger: warnings and above
    } else {
        # Development: permissive logger filter, receiver-level control
        log_this %>%
            with_receivers(
                to_console(lower = CHATTER),      # Console: verbose output
                to_identity()                         # File: everything
            ) %>%
            with_limits(lower = CHATTER, upper = HIGHEST)  # Logger: everything
    }
}
```

## Shiny Application Integration

`logthis` provides seamless integration with Shiny applications through the `to_shinyalert()` receiver:

```{r shiny-example, eval=FALSE}
library(shiny)
library(logthis)
library(shinyalert)

# Setup application logger
app_logger <- logger() %>%
    with_receivers(
        to_console(lower = CHATTER),    # All events to console
        to_shinyalert(lower = ERROR)        # Only errors as alerts
    )

ui <- fluidPage(
    useShinyalert(),
    actionButton("process", "Process Data"),
    actionButton("error", "Trigger Error")
)

server <- function(input, output, session) {
    observeEvent(input$process, {
        app_logger(NOTE("User clicked process button"))
        
        tryCatch({
            # Simulate processing
            app_logger(MESSAGE("Processing started"))
            Sys.sleep(1)
            app_logger(MESSAGE("Processing completed successfully"))
        }, error = function(e) {
            app_logger(ERROR(paste("Processing failed:", e$message)))
        })
    })
    
    observeEvent(input$error, {
        app_logger(ERROR("User triggered an error for testing"))
    })
}

shinyApp(ui, server)
```

## Custom Receivers

You can create custom receivers to send logs to files, databases, or external services:

```{r custom-receivers}
# File logging receiver
to_text_file <- function(filepath, lower = LOWEST, upper = HIGHEST) {
    structure(
        function(event) {
            if (attr(lower, "level_number") <= event$level_number &&
                event$level_number <= attr(upper, "level_number")) {
                
                log_line <- paste0(
                    format(event$time, "%Y-%m-%d %H:%M:%S"), " ",
                    "[", event$level_class, "] ",
                    event$message
                )
                
                cat(log_line, "\n", file = filepath, append = TRUE)
            }
            event
        },
        class = c("log_receiver", "function")
    )
}

# Email notification receiver (pseudo-code)
to_email <- function(recipient, lower = ERROR) {
    structure(
        function(event) {
            if (event$level_number >= attr(lower, "level_number")) {
                # Send email notification
                # email_service$send(
                #     to = recipient,
                #     subject = paste("Log Alert:", event$level_class),
                #     body = event$message
                # )
            }
            event
        },
        class = c("log_receiver", "function")
    )
}
```

## Production Configuration

For production applications, you typically want different logging configurations:

```{r production-config}
# Development logger - verbose output
dev_logger <- logger() %>%
    with_receivers(to_console(lower = CHATTER)) %>%
    with_limits(lower = CHATTER, upper = HIGHEST)

# Production logger - structured logging to file with alerts
prod_logger <- logger() %>%
    with_receivers(
        to_console(lower = WARNING),         # Only warnings+ to console
        # to_text_file("/var/log/app.log"),     # All events to file
        # to_email("admin@company.com")          # Critical errors via email
    ) %>%
    with_limits(lower = NOTE, upper = HIGHEST)

# Environment-aware logger selection
get_logger <- function() {
    if (Sys.getenv("R_ENV") == "production") {
        return(prod_logger)
    } else {
        return(dev_logger)
    }
}

app_logger <- get_logger()
```

## Package Development

When developing R packages, you can include logging capabilities:

```{r package-logging}
# In your package's R/zzz.R file:
.onLoad <- function(libname, pkgname) {
    # Create package-level logger
    pkg_logger <- logger() %>%
        with_receivers(to_console(lower = WARNING)) %>%
        with_limits(lower = NOTE, upper = HIGHEST)
    
    # Store in package environment
    assign("pkg_logger", pkg_logger, envir = parent.env(environment()))
}

# In your package functions:
my_function <- function(x) {
    pkg_logger(NOTE("Function my_function() called"))
    
    if (missing(x)) {
        pkg_logger(WARNING("Argument 'x' is missing, using default"))
        x <- 1
    }
    
    tryCatch({
        result <- x * 2
        pkg_logger(MESSAGE(paste("Computed result:", result)))
        result
    }, error = function(e) {
        pkg_logger(ERROR(paste("Computation failed:", e$message)))
        stop(e)
    })
}
```

## Performance Considerations

For high-performance applications, consider using the dummy logger to disable logging:

```{r performance}
# Create conditional logger based on debug flag
create_logger <- function(debug = FALSE) {
    if (debug) {
        logger() %>%
            with_receivers(to_console()) %>%
            with_limits(lower = CHATTER, upper = HIGHEST)
    } else {
        dummy_logger()  # No-op logger for production
    }
}

# Usage
DEBUG_MODE <- as.logical(Sys.getenv("DEBUG", "FALSE"))
app_logger <- create_logger(DEBUG_MODE)

# These calls have minimal overhead when DEBUG_MODE is FALSE
app_logger(CHATTER("This is expensive debug info"))
app_logger(NOTE("Processing item 1000"))
```

## Error Handling Patterns

Common patterns for error handling with logging:

```{r error-patterns}
# Wrapper function with logging
with_logging <- function(expr, logger = app_logger) {
    tryCatch({
        logger(NOTE("Operation started"))
        result <- expr
        logger(MESSAGE("Operation completed successfully"))
        result
    }, warning = function(w) {
        logger(WARNING(paste("Warning:", w$message)))
        result
    }, error = function(e) {
        logger(ERROR(paste("Error:", e$message)))
        stop(e)
    })
}

# Usage
result <- with_logging({
    # Your risky code here
    if (runif(1) < 0.5) {
        warning("Random warning")
    }
    if (runif(1) < 0.2) {
        stop("Random error")
    }
    "Success!"
})
```

## Testing Logged Applications

Use the identity receiver to capture and test log events:

```{r testing}
# Test logger setup
test_logger <- logger() %>%
    with_receivers(to_identity())

# Capture log events for testing
result <- test_logger(WARNING("Test warning"))

# Verify log event properties
stopifnot(result$level_class == "WARNING")
stopifnot(result$message == "Test warning")
stopifnot(!is.null(result$time))
```

This covers the advanced usage patterns of `logthis`. The package is designed to be flexible enough to handle a wide variety of logging requirements while maintaining a consistent API.